{"ast":null,"code":"var _jsxFileName = \"D:\\\\Developer\\\\Personal\\\\Games\\\\Multiplayer-Blackjack\\\\client\\\\src\\\\contexts\\\\AuthContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { supabase } from '../config/supabase';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext();\nexport const useAuth = () => {\n  _s();\n  return useContext(AuthContext);\n};\n_s(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AuthProvider = ({\n  children\n}) => {\n  _s2();\n  const [user, setUser] = useState(null);\n  const [session, setSession] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [balance, setBalance] = useState(1000);\n  const [username, setUsername] = useState('');\n\n  // Generate guest username\n  const generateGuestUsername = () => {\n    const randomNum = Math.floor(Math.random() * 10000);\n    return `guest${randomNum}`;\n  };\n\n  // Initialize auth state\n  useEffect(() => {\n    // Check for existing session\n    supabase.auth.getSession().then(({\n      data: {\n        session\n      },\n      error\n    }) => {\n      var _session$user;\n      if (error) {\n        console.error('Error getting session:', error);\n        setLoading(false);\n        return;\n      }\n      setSession(session);\n      setUser((_session$user = session === null || session === void 0 ? void 0 : session.user) !== null && _session$user !== void 0 ? _session$user : null);\n      if (session !== null && session !== void 0 && session.user) {\n        loadUserBalance(session.user.id);\n        loadUsername(session.user.id);\n      } else {\n        // Don't auto-create guest - wait for user to choose\n        // Only set guest if they've explicitly chosen guest mode (stored in sessionStorage)\n        const guestMode = sessionStorage.getItem('guestMode');\n        if (guestMode === 'true') {\n          const guestUsername = generateGuestUsername();\n          setUsername(guestUsername);\n          setBalance(1000);\n        }\n        // Otherwise, username stays empty to show auth screen\n      }\n      setLoading(false);\n    });\n\n    // Listen for auth changes\n    const {\n      data: {\n        subscription\n      }\n    } = supabase.auth.onAuthStateChange((_event, session) => {\n      var _session$user2;\n      setSession(session);\n      setUser((_session$user2 = session === null || session === void 0 ? void 0 : session.user) !== null && _session$user2 !== void 0 ? _session$user2 : null);\n      if (session !== null && session !== void 0 && session.user) {\n        loadUserBalance(session.user.id);\n        loadUsername(session.user.id);\n        // Clear guest mode if user signs in\n        sessionStorage.removeItem('guestMode');\n      } else {\n        // Check if guest mode was previously set\n        const guestMode = sessionStorage.getItem('guestMode');\n        if (guestMode === 'true') {\n          const guestUsername = generateGuestUsername();\n          setUsername(guestUsername);\n          setBalance(1000);\n        } else {\n          // User signed out - clear username to show auth screen again\n          setUsername('');\n          setBalance(1000);\n        }\n      }\n    });\n    return () => subscription.unsubscribe();\n  }, []);\n\n  // Load user balance from Supabase\n  const loadUserBalance = async userId => {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('user_balances').select('balance').eq('user_id', userId).maybeSingle(); // Use maybeSingle instead of single to handle null gracefully\n\n      if (error) {\n        // Only log if it's not a \"not found\" error\n        if (error.code !== 'PGRST116' && error.code !== '42P01') {\n          console.error('Error loading balance:', error);\n        }\n        // Default balance on error\n        setBalance(1000);\n        return;\n      }\n      if (data && data.balance !== undefined && data.balance !== null) {\n        // If balance is 0 or less, reset to 1000\n        setBalance(data.balance > 0 ? data.balance : 1000);\n      } else {\n        // No record exists, create one with default balance\n        await createUserBalance(userId, 1000);\n        setBalance(1000);\n      }\n    } catch (error) {\n      console.error('Error loading balance:', error);\n      setBalance(1000);\n    }\n  };\n\n  // Load username from Supabase\n  const loadUsername = async userId => {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.from('user_profiles').select('username').eq('user_id', userId).maybeSingle(); // Use maybeSingle instead of single to handle null gracefully\n\n      if (error) {\n        // Only log if it's not a \"not found\" error\n        if (error.code !== 'PGRST116' && error.code !== '42P01') {\n          console.error('Error loading username:', error);\n        }\n        return;\n      }\n      if (data && data.username) {\n        setUsername(data.username);\n      }\n    } catch (error) {\n      console.error('Error loading username:', error);\n    }\n  };\n\n  // Create user balance record\n  const createUserBalance = async (userId, initialBalance = 1000) => {\n    try {\n      const {\n        error\n      } = await supabase.from('user_balances').insert({\n        user_id: userId,\n        balance: initialBalance,\n        updated_at: new Date().toISOString()\n      });\n      if (error) {\n        console.error('Error creating balance:', error);\n      }\n    } catch (error) {\n      console.error('Error creating balance:', error);\n    }\n  };\n\n  // Update user balance in Supabase\n  const updateBalance = async newBalance => {\n    // Always update local state first for immediate UI feedback\n    setBalance(newBalance);\n    if (!user) {\n      // Guest mode - just update local state, don't save\n      return;\n    }\n    try {\n      // If balance is 0 or less, reset to 1000\n      const balanceToSave = newBalance > 0 ? newBalance : 1000;\n      const {\n        error\n      } = await supabase.from('user_balances').upsert({\n        user_id: user.id,\n        balance: balanceToSave,\n        updated_at: new Date().toISOString()\n      }, {\n        onConflict: 'user_id'\n      });\n      if (error) {\n        console.error('Error updating balance:', error);\n        // If update fails, keep the local balance but log the error\n      } else if (balanceToSave !== newBalance) {\n        // If balance was reset, update local state to reflect the reset\n        setBalance(balanceToSave);\n      }\n    } catch (error) {\n      console.error('Error updating balance:', error);\n    }\n  };\n\n  // Sign up\n  const signUp = async (email, password, username) => {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.auth.signUp({\n        email,\n        password,\n        options: {\n          data: {\n            username: username\n          },\n          emailRedirectTo: window.location.origin\n        }\n      });\n      if (error) throw error;\n\n      // The trigger function should automatically create the profile and balance\n      // But we need to update the profile with the username and email if they weren't set by the trigger\n      if (data.user) {\n        // Wait a moment for the trigger to execute\n        await new Promise(resolve => setTimeout(resolve, 500));\n\n        // Update the profile with username and email (trigger might have created it with defaults)\n        const {\n          error: updateError\n        } = await supabase.from('user_profiles').update({\n          username: username,\n          email: email\n        }).eq('user_id', data.user.id);\n        if (updateError) {\n          console.error('Error updating profile:', updateError);\n          // If update fails, try to insert (in case trigger didn't run)\n          const {\n            error: insertError\n          } = await supabase.from('user_profiles').insert({\n            user_id: data.user.id,\n            username: username,\n            email: email,\n            created_at: new Date().toISOString()\n          });\n          if (insertError) {\n            console.error('Error inserting profile:', insertError);\n          }\n        }\n\n        // If session exists (email confirmation disabled), set username immediately\n        if (data.session) {\n          setUsername(username);\n          await loadUserBalance(data.user.id);\n        } else {\n          // Email confirmation required - show message\n          return {\n            data,\n            error: null,\n            requiresConfirmation: true\n          };\n        }\n      }\n      return {\n        data,\n        error: null\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error\n      };\n    }\n  };\n\n  // Sign in - accepts either email or username\n  const signIn = async (emailOrUsername, password) => {\n    try {\n      let emailToUse = emailOrUsername;\n\n      // Check if input is a username (doesn't contain @)\n      if (!emailOrUsername.includes('@')) {\n        var _emailData$;\n        // Look up email by username using RPC function\n        const {\n          data: emailData,\n          error: rpcError\n        } = await supabase.rpc('get_email_by_username', {\n          username_to_find: emailOrUsername\n        });\n        if (rpcError || !emailData || emailData.length === 0 || !((_emailData$ = emailData[0]) !== null && _emailData$ !== void 0 && _emailData$.email)) {\n          // Fallback to direct query if RPC doesn't work\n          const {\n            data: profileData,\n            error: profileError\n          } = await supabase.from('user_profiles').select('email').eq('username', emailOrUsername).maybeSingle();\n          if (profileError || !profileData || !profileData.email) {\n            return {\n              data: null,\n              error: {\n                message: 'Invalid username or password'\n              }\n            };\n          }\n          emailToUse = profileData.email;\n        } else {\n          emailToUse = emailData[0].email;\n        }\n      }\n      const {\n        data,\n        error\n      } = await supabase.auth.signInWithPassword({\n        email: emailToUse,\n        password\n      });\n      if (error) throw error;\n      if (data.user) {\n        await loadUserBalance(data.user.id);\n        await loadUsername(data.user.id);\n      }\n      return {\n        data,\n        error: null\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error\n      };\n    }\n  };\n\n  // Sign out\n  const signOut = async () => {\n    try {\n      const {\n        error\n      } = await supabase.auth.signOut();\n      if (error) throw error;\n\n      // Clear guest mode and reset\n      sessionStorage.removeItem('guestMode');\n      setUsername('');\n      setBalance(1000);\n    } catch (error) {\n      console.error('Error signing out:', error);\n    }\n  };\n\n  // Continue as guest\n  const continueAsGuest = () => {\n    const guestUsername = generateGuestUsername();\n    setUsername(guestUsername);\n    setBalance(1000);\n    // Store guest mode in sessionStorage so it persists on refresh\n    sessionStorage.setItem('guestMode', 'true');\n  };\n  const value = {\n    user,\n    session,\n    loading,\n    balance,\n    username,\n    setBalance: updateBalance,\n    signUp,\n    signIn,\n    signOut,\n    continueAsGuest,\n    isGuest: !user\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 348,\n    columnNumber: 10\n  }, this);\n};\n_s2(AuthProvider, \"wagTIdY9ehJetK+eGepWkg7MszI=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","supabase","jsxDEV","_jsxDEV","AuthContext","useAuth","_s","AuthProvider","children","_s2","user","setUser","session","setSession","loading","setLoading","balance","setBalance","username","setUsername","generateGuestUsername","randomNum","Math","floor","random","auth","getSession","then","data","error","_session$user","console","loadUserBalance","id","loadUsername","guestMode","sessionStorage","getItem","guestUsername","subscription","onAuthStateChange","_event","_session$user2","removeItem","unsubscribe","userId","from","select","eq","maybeSingle","code","undefined","createUserBalance","initialBalance","insert","user_id","updated_at","Date","toISOString","updateBalance","newBalance","balanceToSave","upsert","onConflict","signUp","email","password","options","emailRedirectTo","window","location","origin","Promise","resolve","setTimeout","updateError","update","insertError","created_at","requiresConfirmation","signIn","emailOrUsername","emailToUse","includes","_emailData$","emailData","rpcError","rpc","username_to_find","length","profileData","profileError","message","signInWithPassword","signOut","continueAsGuest","setItem","value","isGuest","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/Developer/Personal/Games/Multiplayer-Blackjack/client/src/contexts/AuthContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\r\nimport { supabase } from '../config/supabase';\r\n\r\nconst AuthContext = createContext();\r\n\r\nexport const useAuth = () => useContext(AuthContext);\r\n\r\nexport const AuthProvider = ({ children }) => {\r\n  const [user, setUser] = useState(null);\r\n  const [session, setSession] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [balance, setBalance] = useState(1000);\r\n  const [username, setUsername] = useState('');\r\n\r\n  // Generate guest username\r\n  const generateGuestUsername = () => {\r\n    const randomNum = Math.floor(Math.random() * 10000);\r\n    return `guest${randomNum}`;\r\n  };\r\n\r\n  // Initialize auth state\r\n  useEffect(() => {\r\n    // Check for existing session\r\n    supabase.auth.getSession().then(({ data: { session }, error }) => {\r\n      if (error) {\r\n        console.error('Error getting session:', error);\r\n        setLoading(false);\r\n        return;\r\n      }\r\n      \r\n      setSession(session);\r\n      setUser(session?.user ?? null);\r\n      if (session?.user) {\r\n        loadUserBalance(session.user.id);\r\n        loadUsername(session.user.id);\r\n      } else {\r\n        // Don't auto-create guest - wait for user to choose\r\n        // Only set guest if they've explicitly chosen guest mode (stored in sessionStorage)\r\n        const guestMode = sessionStorage.getItem('guestMode');\r\n        if (guestMode === 'true') {\r\n          const guestUsername = generateGuestUsername();\r\n          setUsername(guestUsername);\r\n          setBalance(1000);\r\n        }\r\n        // Otherwise, username stays empty to show auth screen\r\n      }\r\n      setLoading(false);\r\n    });\r\n\r\n    // Listen for auth changes\r\n    const {\r\n      data: { subscription },\r\n    } = supabase.auth.onAuthStateChange((_event, session) => {\r\n      setSession(session);\r\n      setUser(session?.user ?? null);\r\n      if (session?.user) {\r\n        loadUserBalance(session.user.id);\r\n        loadUsername(session.user.id);\r\n        // Clear guest mode if user signs in\r\n        sessionStorage.removeItem('guestMode');\r\n      } else {\r\n        // Check if guest mode was previously set\r\n        const guestMode = sessionStorage.getItem('guestMode');\r\n        if (guestMode === 'true') {\r\n          const guestUsername = generateGuestUsername();\r\n          setUsername(guestUsername);\r\n          setBalance(1000);\r\n        } else {\r\n          // User signed out - clear username to show auth screen again\r\n          setUsername('');\r\n          setBalance(1000);\r\n        }\r\n      }\r\n    });\r\n\r\n    return () => subscription.unsubscribe();\r\n  }, []);\r\n\r\n  // Load user balance from Supabase\r\n  const loadUserBalance = async (userId) => {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('user_balances')\r\n        .select('balance')\r\n        .eq('user_id', userId)\r\n        .maybeSingle(); // Use maybeSingle instead of single to handle null gracefully\r\n\r\n      if (error) {\r\n        // Only log if it's not a \"not found\" error\r\n        if (error.code !== 'PGRST116' && error.code !== '42P01') {\r\n          console.error('Error loading balance:', error);\r\n        }\r\n        // Default balance on error\r\n        setBalance(1000);\r\n        return;\r\n      }\r\n\r\n      if (data && data.balance !== undefined && data.balance !== null) {\r\n        // If balance is 0 or less, reset to 1000\r\n        setBalance(data.balance > 0 ? data.balance : 1000);\r\n      } else {\r\n        // No record exists, create one with default balance\r\n        await createUserBalance(userId, 1000);\r\n        setBalance(1000);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading balance:', error);\r\n      setBalance(1000);\r\n    }\r\n  };\r\n\r\n  // Load username from Supabase\r\n  const loadUsername = async (userId) => {\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('user_profiles')\r\n        .select('username')\r\n        .eq('user_id', userId)\r\n        .maybeSingle(); // Use maybeSingle instead of single to handle null gracefully\r\n\r\n      if (error) {\r\n        // Only log if it's not a \"not found\" error\r\n        if (error.code !== 'PGRST116' && error.code !== '42P01') {\r\n          console.error('Error loading username:', error);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (data && data.username) {\r\n        setUsername(data.username);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading username:', error);\r\n    }\r\n  };\r\n\r\n  // Create user balance record\r\n  const createUserBalance = async (userId, initialBalance = 1000) => {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('user_balances')\r\n        .insert({\r\n          user_id: userId,\r\n          balance: initialBalance,\r\n          updated_at: new Date().toISOString()\r\n        });\r\n\r\n      if (error) {\r\n        console.error('Error creating balance:', error);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error creating balance:', error);\r\n    }\r\n  };\r\n\r\n  // Update user balance in Supabase\r\n  const updateBalance = async (newBalance) => {\r\n    // Always update local state first for immediate UI feedback\r\n    setBalance(newBalance);\r\n    \r\n    if (!user) {\r\n      // Guest mode - just update local state, don't save\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // If balance is 0 or less, reset to 1000\r\n      const balanceToSave = newBalance > 0 ? newBalance : 1000;\r\n\r\n      const { error } = await supabase\r\n        .from('user_balances')\r\n        .upsert({\r\n          user_id: user.id,\r\n          balance: balanceToSave,\r\n          updated_at: new Date().toISOString()\r\n        }, {\r\n          onConflict: 'user_id'\r\n        });\r\n\r\n      if (error) {\r\n        console.error('Error updating balance:', error);\r\n        // If update fails, keep the local balance but log the error\r\n      } else if (balanceToSave !== newBalance) {\r\n        // If balance was reset, update local state to reflect the reset\r\n        setBalance(balanceToSave);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error updating balance:', error);\r\n    }\r\n  };\r\n\r\n  // Sign up\r\n  const signUp = async (email, password, username) => {\r\n    try {\r\n      const { data, error } = await supabase.auth.signUp({\r\n        email,\r\n        password,\r\n        options: {\r\n          data: {\r\n            username: username\r\n          },\r\n          emailRedirectTo: window.location.origin\r\n        }\r\n      });\r\n\r\n      if (error) throw error;\r\n\r\n      // The trigger function should automatically create the profile and balance\r\n      // But we need to update the profile with the username and email if they weren't set by the trigger\r\n      if (data.user) {\r\n        // Wait a moment for the trigger to execute\r\n        await new Promise(resolve => setTimeout(resolve, 500));\r\n        \r\n        // Update the profile with username and email (trigger might have created it with defaults)\r\n        const { error: updateError } = await supabase\r\n          .from('user_profiles')\r\n          .update({\r\n            username: username,\r\n            email: email\r\n          })\r\n          .eq('user_id', data.user.id);\r\n\r\n        if (updateError) {\r\n          console.error('Error updating profile:', updateError);\r\n          // If update fails, try to insert (in case trigger didn't run)\r\n          const { error: insertError } = await supabase\r\n            .from('user_profiles')\r\n            .insert({\r\n              user_id: data.user.id,\r\n              username: username,\r\n              email: email,\r\n              created_at: new Date().toISOString()\r\n            });\r\n          \r\n          if (insertError) {\r\n            console.error('Error inserting profile:', insertError);\r\n          }\r\n        }\r\n        \r\n        // If session exists (email confirmation disabled), set username immediately\r\n        if (data.session) {\r\n          setUsername(username);\r\n          await loadUserBalance(data.user.id);\r\n        } else {\r\n          // Email confirmation required - show message\r\n          return { \r\n            data, \r\n            error: null,\r\n            requiresConfirmation: true \r\n          };\r\n        }\r\n      }\r\n\r\n      return { data, error: null };\r\n    } catch (error) {\r\n      return { data: null, error };\r\n    }\r\n  };\r\n\r\n  // Sign in - accepts either email or username\r\n  const signIn = async (emailOrUsername, password) => {\r\n    try {\r\n      let emailToUse = emailOrUsername;\r\n\r\n      // Check if input is a username (doesn't contain @)\r\n      if (!emailOrUsername.includes('@')) {\r\n        // Look up email by username using RPC function\r\n        const { data: emailData, error: rpcError } = await supabase\r\n          .rpc('get_email_by_username', { username_to_find: emailOrUsername });\r\n\r\n        if (rpcError || !emailData || emailData.length === 0 || !emailData[0]?.email) {\r\n          // Fallback to direct query if RPC doesn't work\r\n          const { data: profileData, error: profileError } = await supabase\r\n            .from('user_profiles')\r\n            .select('email')\r\n            .eq('username', emailOrUsername)\r\n            .maybeSingle();\r\n\r\n          if (profileError || !profileData || !profileData.email) {\r\n            return { \r\n              data: null, \r\n              error: { message: 'Invalid username or password' } \r\n            };\r\n          }\r\n\r\n          emailToUse = profileData.email;\r\n        } else {\r\n          emailToUse = emailData[0].email;\r\n        }\r\n      }\r\n\r\n      const { data, error } = await supabase.auth.signInWithPassword({\r\n        email: emailToUse,\r\n        password,\r\n      });\r\n\r\n      if (error) throw error;\r\n\r\n      if (data.user) {\r\n        await loadUserBalance(data.user.id);\r\n        await loadUsername(data.user.id);\r\n      }\r\n\r\n      return { data, error: null };\r\n    } catch (error) {\r\n      return { data: null, error };\r\n    }\r\n  };\r\n\r\n  // Sign out\r\n  const signOut = async () => {\r\n    try {\r\n      const { error } = await supabase.auth.signOut();\r\n      if (error) throw error;\r\n      \r\n      // Clear guest mode and reset\r\n      sessionStorage.removeItem('guestMode');\r\n      setUsername('');\r\n      setBalance(1000);\r\n    } catch (error) {\r\n      console.error('Error signing out:', error);\r\n    }\r\n  };\r\n\r\n  // Continue as guest\r\n  const continueAsGuest = () => {\r\n    const guestUsername = generateGuestUsername();\r\n    setUsername(guestUsername);\r\n    setBalance(1000);\r\n    // Store guest mode in sessionStorage so it persists on refresh\r\n    sessionStorage.setItem('guestMode', 'true');\r\n  };\r\n\r\n  const value = {\r\n    user,\r\n    session,\r\n    loading,\r\n    balance,\r\n    username,\r\n    setBalance: updateBalance,\r\n    signUp,\r\n    signIn,\r\n    signOut,\r\n    continueAsGuest,\r\n    isGuest: !user\r\n  };\r\n\r\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}